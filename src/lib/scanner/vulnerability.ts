import * as cheerio from 'cheerio';
import type { ScanFinding } from '@/types';

type FindingInput = Omit<ScanFinding, 'id' | 'scan_id' | 'created_at'>;

export async function checkVulnerabilities(
  domain: string,
  html: string,
  url: string,
  crawledUrls: string[]
): Promise<FindingInput[]> {
  const findings: FindingInput[] = [];

  // 1. Check for forms without CSRF tokens
  checkCsrf(html, url, findings);

  // 2. Check for reflected XSS potential on parameters
  await checkReflectedXss(domain, crawledUrls, findings);

  // 3. Check for open redirects
  await checkOpenRedirects(domain, findings);

  // 4. Check for clickjacking vulnerability
  checkClickjacking(html, url, findings);

  // 5. Check for mixed content
  checkMixedContent(html, url, findings);

  // 6. Check for autocomplete on sensitive fields
  checkAutocomplete(html, url, findings);

  // 7. Check cookies
  await checkCookies(domain, findings);

  // 8. Check Subresource Integrity (SRI)
  checkSri(html, url, findings);

  // 9. Check for DOM-based XSS sinks
  checkDomXssSinks(html, url, findings);

  // 10. Check for information disclosure in error pages
  await checkErrorPages(domain, findings);

  // 11. Check for HTTP methods
  await checkHttpMethods(domain, findings);

  // 12. Check for form action hijacking
  checkFormActions(html, url, findings);

  // 13. Check cookie prefixes (__Secure-, __Host-)
  await checkCookiePrefixes(domain, findings);

  return findings;
}

// ── CSRF Check ───────────────────────────────────────────────────────────
function checkCsrf(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const forms = $('form');

  forms.each((_, form) => {
    const method = $(form).attr('method')?.toUpperCase() || 'GET';
    if (method !== 'POST') return;

    const action = $(form).attr('action') || url;
    const hasToken =
      $(form).find('input[name*="csrf"]').length > 0 ||
      $(form).find('input[name*="token"]').length > 0 ||
      $(form).find('input[name*="_token"]').length > 0 ||
      $(form).find('input[name*="authenticity"]').length > 0 ||
      $(form).find('input[name*="nonce"]').length > 0 ||
      $(form).find('input[name*="__RequestVerificationToken"]').length > 0;

    if (!hasToken) {
      findings.push({
        category: 'vulnerability',
        severity: 'medium',
        title: 'Formular ohne CSRF-Schutz',
        description: `Ein POST-Formular (Aktion: ${action}) hat kein erkennbares CSRF-Token. Angreifer könnten Benutzer dazu bringen, unbeabsichtigte Aktionen auszuführen.`,
        affected_url: url,
        recommendation:
          'Implementiere CSRF-Tokens für alle zustandsverändernden Formulare.',
        details: { formAction: action, method },
      });
    }
  });
}

// ── Reflected XSS Check ──────────────────────────────────────────────────
async function checkReflectedXss(
  domain: string,
  crawledUrls: string[],
  findings: FindingInput[]
) {
  // Harmless probe that can't execute JavaScript
  const probe = 'testme_xss_probe_7x8z9';
  const htmlProbe = '<testme>';

  // Collect URLs with parameters
  const urlsWithParams: URL[] = [];

  for (const urlStr of crawledUrls) {
    try {
      const u = new URL(urlStr);
      if (u.searchParams.toString().length > 0) {
        urlsWithParams.push(u);
      }
    } catch {
      // ignore
    }
  }

  // Also try common parameter patterns
  const commonPaths = [
    `https://${domain}/search?q=${probe}`,
    `https://${domain}/?s=${probe}`,
    `https://${domain}/search?query=${probe}`,
    `https://${domain}/?search=${probe}`,
  ];

  for (const pathUrl of commonPaths) {
    try {
      const response = await fetch(pathUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'follow',
      });
      if (response.ok) {
        const body = await response.text();
        if (body.includes(probe)) {
          // Now test with HTML characters
          const htmlTestUrl = pathUrl.replace(probe, encodeURIComponent(htmlProbe));
          const htmlResponse = await fetch(htmlTestUrl, {
            signal: AbortSignal.timeout(8000),
            headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
            redirect: 'follow',
          });
          if (htmlResponse.ok) {
            const htmlBody = await htmlResponse.text();
            if (htmlBody.includes('<testme>')) {
              const paramName = new URL(pathUrl).searchParams.keys().next().value;
              findings.push({
                category: 'vulnerability',
                severity: 'high',
                title: `Mögliche Reflected XSS in Parameter "${paramName}"`,
                description: `Der Parameter "${paramName}" reflektiert HTML-Zeichen ohne Encoding. Ein Angreifer kann beliebigen HTML/JavaScript-Code einschleusen.`,
                affected_url: pathUrl,
                recommendation:
                  'Enkodiere alle Benutzereingaben vor der Ausgabe in HTML (HTML Entity Encoding). Nutze ein Template-System mit Auto-Escaping.',
                details: { parameter: paramName, type: 'reflected-xss' },
              });
            }
          }
        }
      }
    } catch {
      // Ignore
    }
    await new Promise((r) => setTimeout(r, 200));
  }

  // Test parameters from crawled URLs
  for (const u of urlsWithParams.slice(0, 8)) {
    for (const [paramName] of u.searchParams) {
      try {
        const testUrl = new URL(u.href);
        testUrl.searchParams.set(paramName, probe);

        const response = await fetch(testUrl.href, {
          signal: AbortSignal.timeout(8000),
          headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
          redirect: 'follow',
        });

        if (response.ok) {
          const body = await response.text();
          if (body.includes(probe)) {
            // Test HTML encoding
            testUrl.searchParams.set(paramName, htmlProbe);
            const htmlResponse = await fetch(testUrl.href, {
              signal: AbortSignal.timeout(8000),
              headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
              redirect: 'follow',
            });

            if (htmlResponse.ok) {
              const htmlBody = await htmlResponse.text();
              if (htmlBody.includes('<testme>')) {
                findings.push({
                  category: 'vulnerability',
                  severity: 'high',
                  title: `Mögliche Reflected XSS in "${paramName}"`,
                  description: `Der Parameter "${paramName}" reflektiert HTML-Zeichen ohne Encoding auf ${u.pathname}.`,
                  affected_url: u.href,
                  recommendation: 'Implementiere Output-Encoding für alle Benutzereingaben.',
                  details: { parameter: paramName, path: u.pathname },
                });
                break; // One finding per URL
              }
            }
          }
        }
      } catch {
        // Ignore
      }
      await new Promise((r) => setTimeout(r, 150));
    }
  }
}

// ── Open Redirect Check ──────────────────────────────────────────────────
async function checkOpenRedirects(domain: string, findings: FindingInput[]) {
  const redirectParams = [
    'redirect', 'url', 'next', 'return', 'returnTo', 'redirect_uri',
    'redirect_url', 'redir', 'destination', 'continue', 'return_url',
    'go', 'target', 'link', 'out', 'forward',
  ];
  const evilUrl = 'https://evil-redirect-test.example.com';

  for (const param of redirectParams) {
    try {
      const testUrl = `https://${domain}/?${param}=${encodeURIComponent(evilUrl)}`;
      const response = await fetch(testUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'manual',
      });

      const location = response.headers.get('location');
      if (location && location.includes('evil-redirect-test.example.com')) {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: `Open Redirect über Parameter "${param}"`,
          description: `Der Parameter "${param}" ermöglicht eine Weiterleitung zu beliebigen externen URLs. Angreifer können dies für Phishing nutzen.`,
          affected_url: `https://${domain}/?${param}=...`,
          recommendation:
            'Validiere Weiterleitungs-URLs serverseitig. Erlaube nur relative Pfade oder eine Whitelist vertrauenswürdiger Domains.',
          details: { parameter: param, redirectTo: location },
        });
        break; // One finding is enough
      }
    } catch {
      // Ignore
    }
    await new Promise((r) => setTimeout(r, 100));
  }

  // Also check common redirect paths
  const redirectPaths = ['/redirect?url=', '/login?next=', '/auth/callback?redirect='];
  for (const path of redirectPaths) {
    try {
      const testUrl = `https://${domain}${path}${encodeURIComponent(evilUrl)}`;
      const response = await fetch(testUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'manual',
      });

      const location = response.headers.get('location');
      if (location && location.includes('evil-redirect-test.example.com')) {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: `Open Redirect auf Pfad "${path.split('?')[0]}"`,
          description: `Der Redirect-Endpunkt leitet zu beliebigen externen URLs weiter.`,
          affected_url: `https://${domain}${path}...`,
          recommendation: 'Validiere Redirect-Ziele serverseitig.',
          details: { path },
        });
        break;
      }
    } catch {
      // Ignore
    }
  }
}

// ── Clickjacking Check ───────────────────────────────────────────────────
function checkClickjacking(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const metaCsp = $('meta[http-equiv="Content-Security-Policy"]').attr('content');
  const hasFrameAncestors = metaCsp?.includes('frame-ancestors');

  // Note: The header check is done in headers.ts, this checks the HTML meta tag
  if (!hasFrameAncestors) {
    // Check if there are any interactive elements that could be targeted
    const hasSensitiveForms =
      $('form[method="post"]').length > 0 || $('button').length > 0 || $('a[href*="delete"]').length > 0;

    if (hasSensitiveForms) {
      findings.push({
        category: 'vulnerability',
        severity: 'medium',
        title: 'Clickjacking-Schutz unvollständig',
        description:
          'Die Seite enthält interaktive Elemente (Formulare, Buttons), aber kein frame-ancestors in der Meta-CSP. Prüfe, ob X-Frame-Options oder CSP frame-ancestors als HTTP-Header gesetzt sind.',
        affected_url: url,
        recommendation:
          "Setze 'Content-Security-Policy: frame-ancestors 'none'' oder 'X-Frame-Options: DENY' als HTTP-Header.",
        details: { hasSensitiveForms },
      });
    }
  }
}

// ── Mixed Content Check ──────────────────────────────────────────────────
function checkMixedContent(html: string, url: string, findings: FindingInput[]) {
  if (!url.startsWith('https://')) return;

  const $ = cheerio.load(html);
  const mixedResources: string[] = [];

  // Active mixed content (scripts, iframes, styles)
  const activeMixed: string[] = [];
  $('script[src^="http://"]').each((_, el) => { activeMixed.push($(el).attr('src') || ''); });
  $('iframe[src^="http://"]').each((_, el) => { activeMixed.push($(el).attr('src') || ''); });
  $('link[rel="stylesheet"][href^="http://"]').each((_, el) => { activeMixed.push($(el).attr('href') || ''); });
  $('object[data^="http://"]').each((_, el) => { activeMixed.push($(el).attr('data') || ''); });

  if (activeMixed.length > 0) {
    findings.push({
      category: 'vulnerability',
      severity: 'high',
      title: 'Aktiver Mixed Content erkannt',
      description: `${activeMixed.length} Script(s)/Stylesheet(s)/iFrame(s) werden über unsicheres HTTP auf einer HTTPS-Seite geladen. Browser blockieren dies teilweise, aber es ermöglicht Man-in-the-Middle-Angriffe.`,
      affected_url: url,
      recommendation: 'Ändere alle HTTP-URLs zu HTTPS oder verwende protokoll-relative URLs.',
      details: { activeResources: activeMixed.slice(0, 10) },
    });
  }

  // Passive mixed content (images, videos, audio)
  $('img[src^="http://"]').each((_, el) => { mixedResources.push($(el).attr('src') || ''); });
  $('video[src^="http://"]').each((_, el) => { mixedResources.push($(el).attr('src') || ''); });
  $('audio[src^="http://"]').each((_, el) => { mixedResources.push($(el).attr('src') || ''); });

  if (mixedResources.length > 0) {
    findings.push({
      category: 'vulnerability',
      severity: 'low',
      title: 'Passiver Mixed Content erkannt',
      description: `${mixedResources.length} Bild(er)/Video(s)/Audio-Dateien werden über HTTP geladen.`,
      affected_url: url,
      recommendation: 'Lade alle Ressourcen über HTTPS.',
      details: { passiveResources: mixedResources.slice(0, 10) },
    });
  }
}

// ── Autocomplete Check ───────────────────────────────────────────────────
function checkAutocomplete(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const sensitiveInputs = $('input[type="password"], input[name*="card"], input[name*="credit"], input[name*="cvv"], input[name*="cvc"], input[name*="ssn"], input[name*="social"]');

  sensitiveInputs.each((_, el) => {
    const autocomplete = $(el).attr('autocomplete');
    const name = $(el).attr('name') || $(el).attr('id') || 'unknown';

    if (autocomplete !== 'off' && autocomplete !== 'new-password') {
      findings.push({
        category: 'vulnerability',
        severity: 'low',
        title: `Autocomplete auf sensiblem Feld "${name}"`,
        description: `Das sensible Eingabefeld "${name}" hat kein autocomplete="off". Browser können den Wert speichern und automatisch ausfüllen.`,
        affected_url: url,
        recommendation: `Setze autocomplete="off" oder autocomplete="new-password" für das Feld "${name}".`,
        details: { fieldName: name, fieldType: $(el).attr('type') },
      });
    }
  });
}

// ── Cookie Security Check ────────────────────────────────────────────────
async function checkCookies(domain: string, findings: FindingInput[]) {
  try {
    const response = await fetch(`https://${domain}`, {
      signal: AbortSignal.timeout(10000),
      headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
      redirect: 'follow',
    });

    const setCookieHeaders = response.headers.getSetCookie?.() || [];

    for (const cookie of setCookieHeaders) {
      const parts = cookie.split(';').map((s) => s.trim());
      const nameValue = parts[0]?.split('=')?.[0] || 'Unknown';
      const flags = parts.slice(1).map((p) => p.toLowerCase());

      const hasSecure = flags.some((f) => f === 'secure');
      const hasHttpOnly = flags.some((f) => f === 'httponly');
      const hasSameSite = flags.some((f) => f.startsWith('samesite'));
      const sameSiteValue = flags.find((f) => f.startsWith('samesite'))?.split('=')?.[1]?.trim();

      const issues: string[] = [];
      if (!hasSecure) issues.push('Secure-Flag fehlt');
      if (!hasHttpOnly) issues.push('HttpOnly-Flag fehlt');
      if (!hasSameSite) issues.push('SameSite-Attribut fehlt');
      if (sameSiteValue === 'none' && !hasSecure) issues.push('SameSite=None ohne Secure');

      // Determine severity based on cookie name
      const isSessionCookie =
        nameValue.toLowerCase().includes('session') ||
        nameValue.toLowerCase().includes('auth') ||
        nameValue.toLowerCase().includes('token') ||
        nameValue.toLowerCase().includes('jwt') ||
        nameValue.toLowerCase().includes('sid');

      if (issues.length > 0) {
        findings.push({
          category: 'vulnerability',
          severity: isSessionCookie ? 'high' : 'medium',
          title: `Cookie "${nameValue}" – Sicherheitsflags fehlen`,
          description: `Das Cookie "${nameValue}" hat folgende Probleme: ${issues.join(', ')}. ${isSessionCookie ? 'Da dies ein Session-/Auth-Cookie zu sein scheint, ist das besonders kritisch.' : ''}`,
          affected_url: `https://${domain}`,
          recommendation: `Setze für "${nameValue}": Secure; HttpOnly; SameSite=Lax (oder Strict)`,
          details: { cookie: nameValue, issues, fullCookie: cookie.substring(0, 200) },
        });
      }
    }
  } catch {
    // Ignore cookie check failures
  }
}

// ── Subresource Integrity (SRI) Check ────────────────────────────────────
function checkSri(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const externalWithoutSri: string[] = [];
  const hostname = new URL(url).hostname;

  // Check external scripts
  $('script[src]').each((_, el) => {
    const src = $(el).attr('src') || '';
    const integrity = $(el).attr('integrity');

    try {
      const scriptUrl = new URL(src, url);
      // Only check external scripts (CDN, third-party)
      if (scriptUrl.hostname !== hostname && !integrity) {
        externalWithoutSri.push(src);
      }
    } catch {
      // Skip invalid URLs
    }
  });

  // Check external stylesheets
  $('link[rel="stylesheet"][href]').each((_, el) => {
    const href = $(el).attr('href') || '';
    const integrity = $(el).attr('integrity');

    try {
      const styleUrl = new URL(href, url);
      if (styleUrl.hostname !== hostname && !integrity) {
        externalWithoutSri.push(href);
      }
    } catch {
      // Skip
    }
  });

  if (externalWithoutSri.length > 0) {
    findings.push({
      category: 'vulnerability',
      severity: 'medium',
      title: `${externalWithoutSri.length} externe Ressource(n) ohne Subresource Integrity`,
      description: `Externe Scripts/Stylesheets werden ohne integrity-Attribut geladen. Wird der CDN-Server kompromittiert, kann manipulierter Code eingeschleust werden.`,
      affected_url: url,
      recommendation:
        'Füge integrity und crossorigin Attribute zu externen Script- und Link-Tags hinzu. Generiere Hashes mit srihash.org.',
      details: { resources: externalWithoutSri.slice(0, 10) },
    });
  }
}

// ── DOM-based XSS Sink Detection ─────────────────────────────────────────
function checkDomXssSinks(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const scripts: string[] = [];

  $('script').each((_, el) => {
    const content = $(el).html();
    if (content) scripts.push(content);
  });

  const allScript = scripts.join('\n');

  // Dangerous sinks
  const sinks = [
    { pattern: /\.innerHTML\s*=/, name: 'innerHTML', severity: 'medium' as const },
    { pattern: /\.outerHTML\s*=/, name: 'outerHTML', severity: 'medium' as const },
    { pattern: /document\.write\s*\(/, name: 'document.write', severity: 'high' as const },
    { pattern: /document\.writeln\s*\(/, name: 'document.writeln', severity: 'high' as const },
    { pattern: /eval\s*\(/, name: 'eval()', severity: 'high' as const },
    { pattern: /setTimeout\s*\(\s*['"`]/, name: 'setTimeout mit String', severity: 'medium' as const },
    { pattern: /setInterval\s*\(\s*['"`]/, name: 'setInterval mit String', severity: 'medium' as const },
  ];

  // Dangerous sources (user-controlled input)
  const sources = [
    /location\.hash/,
    /location\.search/,
    /location\.href/,
    /document\.referrer/,
    /window\.name/,
    /document\.URL/,
    /document\.documentURI/,
  ];

  const hasSource = sources.some((s) => s.test(allScript));

  if (hasSource) {
    const dangerousSinks = sinks.filter((s) => s.pattern.test(allScript));
    if (dangerousSinks.length > 0) {
      findings.push({
        category: 'vulnerability',
        severity: 'high',
        title: 'Potenzielle DOM-basierte XSS erkannt',
        description: `Der JavaScript-Code verwendet sowohl user-kontrollierte Quellen (location, referrer) als auch gefährliche Senken (${dangerousSinks.map((s) => s.name).join(', ')}). Dies kann zu DOM-XSS führen.`,
        affected_url: url,
        recommendation:
          'Verwende sichere APIs (textContent statt innerHTML, keine eval()). Validiere und bereinige user-kontrollierte Eingaben.',
        details: { sinks: dangerousSinks.map((s) => s.name) },
      });
    }
  }
}

// ── Error Page Information Disclosure ─────────────────────────────────────
async function checkErrorPages(domain: string, findings: FindingInput[]) {
  const errorTriggers = [
    `https://${domain}/this-page-does-not-exist-testme-404-${Date.now()}`,
    `https://${domain}/%00`, // Null byte
    `https://${domain}/..%2F..%2Fetc%2Fpasswd`, // Path traversal
  ];

  for (const testUrl of errorTriggers) {
    try {
      const response = await fetch(testUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'follow',
      });

      const body = await response.text();
      const lowerBody = body.toLowerCase();

      // Check for stack traces
      const hasStackTrace =
        lowerBody.includes('stack trace') ||
        lowerBody.includes('traceback') ||
        lowerBody.includes('at line') ||
        /at \w+\.\w+\(.*:\d+:\d+\)/.test(body) || // Node.js stack trace
        /File ".*", line \d+/.test(body) || // Python stack trace
        /#\d+ .+\.php\(\d+\)/.test(body); // PHP stack trace

      // Check for debug information
      const hasDebugInfo =
        lowerBody.includes('debug') && lowerBody.includes('exception') ||
        lowerBody.includes('internal server error') && body.length > 500 ||
        lowerBody.includes('environment variables') ||
        lowerBody.includes('connection string');

      if (hasStackTrace) {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: 'Stack-Trace in Fehlerseite sichtbar',
          description:
            'Die Fehlerseite zeigt einen Stack-Trace mit internen Dateipfaden und Code-Details. Dies hilft Angreifern bei der Identifizierung von Schwachstellen.',
          affected_url: testUrl,
          recommendation:
            'Deaktiviere detaillierte Fehlermeldungen in der Produktion. Zeige nur generische Fehlerseiten an.',
          details: { bodyPreview: body.substring(0, 300) },
        });
        break;
      }

      if (hasDebugInfo) {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: 'Debug-Informationen in Fehlerseite',
          description: 'Die Fehlerseite enthält Debug-Informationen, die in der Produktion nicht sichtbar sein sollten.',
          affected_url: testUrl,
          recommendation: 'Setze die Anwendung in den Produktionsmodus und deaktiviere Debug-Output.',
          details: { bodyPreview: body.substring(0, 300) },
        });
        break;
      }
    } catch {
      // Ignore
    }
    await new Promise((r) => setTimeout(r, 200));
  }
}

// ── HTTP Methods Check ───────────────────────────────────────────────────
async function checkHttpMethods(domain: string, findings: FindingInput[]) {
  const url = `https://${domain}`;

  // Check for TRACE method
  try {
    const response = await fetch(url, {
      method: 'TRACE',
      signal: AbortSignal.timeout(5000),
      headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
    });

    if (response.ok || response.status === 200) {
      findings.push({
        category: 'vulnerability',
        severity: 'medium',
        title: 'HTTP TRACE-Methode aktiviert',
        description:
          'Die HTTP TRACE-Methode ist aktiviert und kann für Cross-Site-Tracing (XST) Angriffe missbraucht werden, um HttpOnly-Cookies zu stehlen.',
        affected_url: url,
        recommendation: 'Deaktiviere die TRACE-Methode in der Webserver-Konfiguration.',
        details: { method: 'TRACE', status: response.status },
      });
    }
  } catch {
    // Method not supported - good
  }

  // Check OPTIONS for overly permissive methods
  try {
    const response = await fetch(url, {
      method: 'OPTIONS',
      signal: AbortSignal.timeout(5000),
      headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
    });

    const allow = response.headers.get('allow') || response.headers.get('access-control-allow-methods') || '';
    const dangerousMethods = ['PUT', 'DELETE', 'PATCH', 'TRACE'];
    const foundDangerous = dangerousMethods.filter((m) => allow.toUpperCase().includes(m));

    if (foundDangerous.length > 0 && allow.toUpperCase().includes('DELETE')) {
      findings.push({
        category: 'vulnerability',
        severity: 'medium',
        title: 'Potenziell gefährliche HTTP-Methoden erlaubt',
        description: `Die folgenden HTTP-Methoden sind erlaubt: ${allow}. Methoden wie DELETE und PUT können missbraucht werden, wenn nicht korrekt abgesichert.`,
        affected_url: url,
        recommendation:
          'Beschränke erlaubte HTTP-Methoden auf GET, POST und HEAD, wenn keine RESTful-API benötigt wird.',
        details: { allowedMethods: allow, dangerousMethods: foundDangerous },
      });
    }
  } catch {
    // Ignore
  }
}

// ── Cookie Prefix Security ───────────────────────────────────────────────
async function checkCookiePrefixes(domain: string, findings: FindingInput[]) {
  try {
    const response = await fetch(`https://${domain}`, {
      signal: AbortSignal.timeout(10000),
      headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
      redirect: 'follow',
    });

    const setCookieHeaders = response.headers.getSetCookie?.() || [];

    for (const cookie of setCookieHeaders) {
      const parts = cookie.split(';').map((s) => s.trim());
      const nameValue = parts[0]?.split('=')?.[0] || '';
      const flags = parts.slice(1).map((p) => p.toLowerCase());

      const hasSecure = flags.some((f) => f === 'secure');
      const hasPath = flags.some((f) => f.startsWith('path='));
      const pathValue = flags.find((f) => f.startsWith('path='))?.split('=')?.[1]?.trim();
      const hasDomain = flags.some((f) => f.startsWith('domain='));

      // Check __Secure- prefix requirements
      if (nameValue.startsWith('__Secure-')) {
        if (!hasSecure) {
          findings.push({
            category: 'vulnerability',
            severity: 'medium',
            title: `Cookie "${nameValue}" – __Secure-Präfix ohne Secure-Flag`,
            description: `Das Cookie "${nameValue}" verwendet den __Secure-Präfix, ist aber nicht mit dem Secure-Flag markiert.`,
            affected_url: `https://${domain}`,
            recommendation: `Setze das Secure-Flag für "${nameValue}".`,
            details: { cookie: nameValue },
          });
        }
      }

      // Check __Host- prefix requirements
      if (nameValue.startsWith('__Host-')) {
        const issues: string[] = [];
        if (!hasSecure) issues.push('Secure fehlt');
        if (hasDomain) issues.push('Domain-Attribut darf nicht gesetzt sein');
        if (!hasPath || pathValue !== '/') issues.push('Path muss "/" sein');

        if (issues.length > 0) {
          findings.push({
            category: 'vulnerability',
            severity: 'medium',
            title: `Cookie "${nameValue}" – __Host-Präfix-Anforderungen nicht erfüllt`,
            description: `Das Cookie "${nameValue}" erfüllt nicht alle __Host-Anforderungen: ${issues.join(', ')}.`,
            affected_url: `https://${domain}`,
            recommendation: `Korrigiere: Secure setzen, Domain entfernen, Path=/ setzen.`,
            details: { cookie: nameValue, issues },
          });
        }
      }

      // Suggest prefixes for session cookies
      const isSessionCookie =
        nameValue.toLowerCase().includes('session') ||
        nameValue.toLowerCase().includes('auth') ||
        nameValue.toLowerCase().includes('token') ||
        nameValue.toLowerCase().includes('sid');

      if (isSessionCookie && !nameValue.startsWith('__Secure-') && !nameValue.startsWith('__Host-') && hasSecure) {
        findings.push({
          category: 'vulnerability',
          severity: 'low',
          title: `Session-Cookie "${nameValue}" ohne Cookie-Präfix`,
          description: `Das Session-Cookie "${nameValue}" könnte mit __Host- oder __Secure-Präfix zusätzlich geschützt werden.`,
          affected_url: `https://${domain}`,
          recommendation: `Verwende den __Host-Präfix: __Host-${nameValue}`,
          details: { cookie: nameValue },
        });
      }
    }
  } catch {
    // Ignore
  }
}

// ── Form Action Security ─────────────────────────────────────────────────
function checkFormActions(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const hostname = new URL(url).hostname;

  $('form[action]').each((_, form) => {
    const action = $(form).attr('action') || '';
    const method = $(form).attr('method')?.toUpperCase() || 'GET';

    try {
      const actionUrl = new URL(action, url);
      // Check for form submitting to external domain
      if (actionUrl.hostname !== hostname && method === 'POST') {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: 'Formular sendet an externe Domain',
          description: `Ein POST-Formular sendet Daten an "${actionUrl.hostname}". Prüfe, ob dies beabsichtigt ist.`,
          affected_url: url,
          recommendation:
            'Stelle sicher, dass Formulare nur an vertrauenswürdige Ziele senden.',
          details: { formAction: action, externalDomain: actionUrl.hostname },
        });
      }

      // Check for form submitting over HTTP
      if (actionUrl.protocol === 'http:' && url.startsWith('https://')) {
        findings.push({
          category: 'vulnerability',
          severity: 'high',
          title: 'Formular sendet über unsicheres HTTP',
          description: `Ein Formular auf einer HTTPS-Seite sendet Daten über unverschlüsseltes HTTP an "${actionUrl.href}".`,
          affected_url: url,
          recommendation: 'Ändere die Form-Action auf HTTPS.',
          details: { formAction: action },
        });
      }
    } catch {
      // Relative URL - fine
    }
  });
}
