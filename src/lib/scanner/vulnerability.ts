import type { ScanFinding } from '@/types';
import * as cheerio from 'cheerio';

type FindingInput = Omit<ScanFinding, 'id' | 'scan_id' | 'created_at'>;

export async function checkVulnerabilities(
  domain: string,
  html: string,
  url: string
): Promise<FindingInput[]> {
  const findings: FindingInput[] = [];

  // 1. Check for forms without CSRF tokens
  checkCsrf(html, url, findings);

  // 2. Check for reflected XSS potential
  await checkReflectedXss(domain, findings);

  // 3. Check for open redirects
  await checkOpenRedirects(domain, findings);

  // 4. Check for clickjacking vulnerability
  checkClickjacking(html, url, findings);

  // 5. Check for mixed content
  checkMixedContent(html, url, findings);

  // 6. Check for autocomplete on sensitive fields
  checkAutocomplete(html, url, findings);

  // 7. Check cookies
  await checkCookies(domain, findings);

  return findings;
}

function checkCsrf(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  const forms = $('form');

  forms.each((_, form) => {
    const method = ($(form).attr('method') || 'get').toLowerCase();
    if (method !== 'post') return;

    const action = $(form).attr('action') || '';
    const hasCSRFToken =
      $(form).find('input[name*="csrf"]').length > 0 ||
      $(form).find('input[name*="token"]').length > 0 ||
      $(form).find('input[name*="_token"]').length > 0 ||
      $(form).find('input[name="authenticity_token"]').length > 0;

    if (!hasCSRFToken) {
      findings.push({
        category: 'vulnerability',
        severity: 'medium',
        title: 'Formular ohne CSRF-Schutz',
        description: `Ein POST-Formular (action: "${action || 'gleiche Seite'}") enthält kein erkennbares CSRF-Token. Dies kann Cross-Site Request Forgery-Angriffe ermöglichen.`,
        affected_url: url,
        recommendation: 'Implementiere CSRF-Tokens in allen POST-Formularen. Die meisten Web-Frameworks bieten dafür eingebaute Mechanismen.',
        details: { formAction: action, method },
      });
    }
  });
}

async function checkReflectedXss(domain: string, findings: FindingInput[]) {
  const testPayload = 'testme_xss_probe_12345';
  const testUrls = [
    `https://${domain}/?q=${testPayload}`,
    `https://${domain}/search?q=${testPayload}`,
    `https://${domain}/?s=${testPayload}`,
  ];

  for (const testUrl of testUrls) {
    try {
      const response = await fetch(testUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'follow',
      });

      if (!response.ok) continue;

      const body = await response.text();

      // Check if our probe is reflected in the page without encoding
      if (body.includes(testPayload)) {
        // Check if it's reflected in a script context or HTML attribute
        const $ = cheerio.load(body);
        const htmlContent = $.html();

        // Check for unescaped reflection in dangerous contexts
        const dangerousPatterns = [
          new RegExp(`<script[^>]*>[^<]*${testPayload}`, 'i'),
          new RegExp(`on\\w+\\s*=\\s*["'][^"']*${testPayload}`, 'i'),
          new RegExp(`href\\s*=\\s*["']javascript:[^"']*${testPayload}`, 'i'),
        ];

        const inDangerousContext = dangerousPatterns.some((p) => p.test(htmlContent));

        findings.push({
          category: 'vulnerability',
          severity: inDangerousContext ? 'high' : 'medium',
          title: 'Potentielle reflektierte XSS-Schwachstelle',
          description: `Ein Eingabeparameter wird ${inDangerousContext ? 'in einem gefährlichen Kontext (Script/Event-Handler)' : 'im HTML'} ungefiltert zurückgegeben. Dies kann für Cross-Site-Scripting-Angriffe ausgenutzt werden.`,
          affected_url: testUrl,
          recommendation: 'Alle Nutzereingaben müssen vor der Ausgabe kontextabhängig escaped werden (HTML-Encoding, JavaScript-Encoding, etc.).',
          details: { dangerousContext: inDangerousContext },
        });
      }
    } catch {
      // Ignore timeout/connection errors
    }
    await new Promise((resolve) => setTimeout(resolve, 300));
  }
}

async function checkOpenRedirects(domain: string, findings: FindingInput[]) {
  const redirectParams = ['url', 'redirect', 'next', 'return', 'returnTo', 'redirect_uri', 'goto'];
  const evilDomain = 'https://evil.example.com';

  for (const param of redirectParams) {
    try {
      const testUrl = `https://${domain}/?${param}=${encodeURIComponent(evilDomain)}`;
      const response = await fetch(testUrl, {
        signal: AbortSignal.timeout(8000),
        headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
        redirect: 'manual',
      });

      const location = response.headers.get('location');
      if (location && location.includes('evil.example.com')) {
        findings.push({
          category: 'vulnerability',
          severity: 'medium',
          title: 'Open Redirect erkannt',
          description: `Der Parameter "${param}" ermöglicht eine Weiterleitung zu einer externen Domain. Angreifer können dies für Phishing nutzen.`,
          affected_url: testUrl,
          recommendation: 'Validiere Weiterleitungs-URLs serverseitig und erlaube nur Weiterleitungen zu eigenen Domains.',
          details: { parameter: param, redirectLocation: location },
        });
      }
    } catch {
      // Ignore
    }
    await new Promise((resolve) => setTimeout(resolve, 200));
  }
}

function checkClickjacking(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);
  // Check if the page contains frame-busting code
  let hasFrameBusting = false;
  $('script').each((_, el) => {
    const content = $(el).html() || '';
    if (
      content.includes('top.location') ||
      content.includes('self !== top') ||
      content.includes('frameElement')
    ) {
      hasFrameBusting = true;
    }
  });

  // If no frame-busting and we already detected missing X-Frame-Options (handled in headers),
  // we note the combined risk
  if (!hasFrameBusting) {
    // This is informational since headers.ts already checks X-Frame-Options
    findings.push({
      category: 'vulnerability',
      severity: 'info',
      title: 'Kein JavaScript-basierter Frame-Busting-Schutz',
      description: 'Die Seite enthält keinen JavaScript-Code zum Schutz gegen Einbettung in Frames. In Kombination mit einem fehlenden X-Frame-Options Header besteht ein Clickjacking-Risiko.',
      affected_url: url,
      recommendation: 'Verwende den X-Frame-Options Header (DENY oder SAMEORIGIN) und/oder CSP frame-ancestors Direktive.',
      details: null,
    });
  }
}

function checkMixedContent(html: string, url: string, findings: FindingInput[]) {
  if (!url.startsWith('https://')) return;

  const $ = cheerio.load(html);
  const mixedResources: string[] = [];

  $('script[src^="http:"]').each((_, el) => {
    mixedResources.push(`Script: ${$(el).attr('src')}`);
  });

  $('link[href^="http:"]').each((_, el) => {
    if ($(el).attr('rel') === 'stylesheet') {
      mixedResources.push(`Stylesheet: ${$(el).attr('href')}`);
    }
  });

  $('img[src^="http:"]').each((_, el) => {
    mixedResources.push(`Bild: ${$(el).attr('src')}`);
  });

  $('iframe[src^="http:"]').each((_, el) => {
    mixedResources.push(`iFrame: ${$(el).attr('src')}`);
  });

  if (mixedResources.length > 0) {
    findings.push({
      category: 'vulnerability',
      severity: 'medium',
      title: 'Mixed Content erkannt',
      description: `Die HTTPS-Seite lädt ${mixedResources.length} Ressource(n) über unsicheres HTTP. Dies untergräbt die Verschlüsselung.`,
      affected_url: url,
      recommendation: 'Ändere alle Ressourcen-URLs auf HTTPS oder verwende protokoll-relative URLs (//).',
      details: { resources: mixedResources.slice(0, 10) },
    });
  }
}

function checkAutocomplete(html: string, url: string, findings: FindingInput[]) {
  const $ = cheerio.load(html);

  const sensitiveInputs = $('input[type="password"], input[name*="credit"], input[name*="card"], input[name*="cvv"], input[name*="ssn"]');

  sensitiveInputs.each((_, el) => {
    const autocomplete = $(el).attr('autocomplete');
    const name = $(el).attr('name') || $(el).attr('type') || 'unbekannt';

    if (autocomplete !== 'off' && autocomplete !== 'new-password') {
      findings.push({
        category: 'vulnerability',
        severity: 'low',
        title: `Autocomplete für sensibles Feld "${name}" aktiv`,
        description: 'Browser könnten sensible Eingaben automatisch speichern und vorschlagen.',
        affected_url: url,
        recommendation: `Setze autocomplete="off" oder autocomplete="new-password" für das Feld "${name}".`,
        details: { fieldName: name, currentAutocomplete: autocomplete },
      });
    }
  });
}

async function checkCookies(domain: string, findings: FindingInput[]) {
  try {
    const response = await fetch(`https://${domain}`, {
      signal: AbortSignal.timeout(10000),
      headers: { 'User-Agent': 'TestMe-Security-Scanner/1.0' },
      redirect: 'follow',
    });

    const setCookieHeaders = response.headers.getSetCookie?.() || [];

    for (const cookie of setCookieHeaders) {
      const parts = cookie.split(';').map((p) => p.trim().toLowerCase());
      const cookieName = cookie.split('=')[0].trim();

      const hasSecure = parts.some((p) => p === 'secure');
      const hasHttpOnly = parts.some((p) => p === 'httponly');
      const hasSameSite = parts.some((p) => p.startsWith('samesite'));

      const issues: string[] = [];
      if (!hasSecure) issues.push('Secure-Flag fehlt');
      if (!hasHttpOnly) issues.push('HttpOnly-Flag fehlt');
      if (!hasSameSite) issues.push('SameSite-Attribut fehlt');

      if (issues.length > 0) {
        findings.push({
          category: 'vulnerability',
          severity: issues.includes('HttpOnly-Flag fehlt') ? 'medium' : 'low',
          title: `Cookie "${cookieName}" – Sicherheitsattribute fehlen`,
          description: `Das Cookie "${cookieName}" hat folgende fehlende Sicherheitsattribute: ${issues.join(', ')}.`,
          affected_url: `https://${domain}`,
          recommendation: 'Setze alle Cookies mit den Attributen Secure, HttpOnly und SameSite=Lax (oder Strict).',
          details: { cookieName, missingAttributes: issues },
        });
      }
    }
  } catch {
    // Ignore cookie check failures
  }
}
